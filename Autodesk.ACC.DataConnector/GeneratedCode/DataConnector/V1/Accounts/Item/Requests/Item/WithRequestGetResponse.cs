// <auto-generated/>
#pragma warning disable CS0618
using Microsoft.Kiota.Abstractions.Extensions;
using Microsoft.Kiota.Abstractions.Serialization;
using System.Collections.Generic;
using System.IO;
using System;
namespace Autodesk.ACC.DataConnector.DataConnector.V1.Accounts.Item.Requests.Item
{
    [global::System.CodeDom.Compiler.GeneratedCode("Kiota", "1.0.0")]
    #pragma warning disable CS1591
    public partial class WithRequestGetResponse : IAdditionalDataHolder, IParsable
    #pragma warning restore CS1591
    {
        /// <summary>The account ID.</summary>
        public Guid? AccountId { get; set; }
        /// <summary>Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.</summary>
        public IDictionary<string, object> AdditionalData { get; set; }
        /// <summary>The callback URL specified for the data request. If specified, the Data Connection service calls the URL each time a job executes for the request. The service sends a POST request that provides job execution information. The JSON payload in the POST request contains the following: ``{ ``accountId``: ``account_id``, ``requestId``: ``request_id``, ``jobId``: ``data_connector_job_id``, ``state``: ``complete``, ``success``: true or false }``.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public string? CallbackUrl { get; set; }
#nullable restore
#else
        public string CallbackUrl { get; set; }
#endif
        /// <summary>The date and time the data request was created, presented in ISO 8601 format.</summary>
        public DateTimeOffset? CreatedAt { get; set; }
        /// <summary>The BIM 360 / ACC user ID of the user who created the data request.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public string? CreatedBy { get; set; }
#nullable restore
#else
        public string CreatedBy { get; set; }
#endif
        /// <summary>The email address of the user who created the data request.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public string? CreatedByEmail { get; set; }
#nullable restore
#else
        public string CreatedByEmail { get; set; }
#endif
        /// <summary>The timeframe used for extracting data in the request. Currently, it is applicable only to the Activities service. This field contains the value specified in the request, indicating the range of data included in the response. Possible values:- ``TODAY``: Data for the current day (from 00:00 UTC to the time the request was made).- ``YESTERDAY``: Data for the previous calendar day (from 00:00 UTC to 23:59 UTC).- ``PAST_7_DAYS``: Data for the last 7 days, including the current day.- ``MONTH_TO_DATE``: Data from the start of the current calendar month (00:00 UTC on the 1st) to the time the request was made.- ``LAST_MONTH``: Data for the entire previous calendar month (00:00 UTC on the 1st to 23:59 UTC on the last day).</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public string? DateRange { get; set; }
#nullable restore
#else
        public string DateRange { get; set; }
#endif
        /// <summary>The user-entered description of this data request. If not supplied, the default value is a null string.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public string? Description { get; set; }
#nullable restore
#else
        public string Description { get; set; }
#endif
        /// <summary>The date and time when a one-time job execution or a recurring interval schedule begins, presented in ISO 8601 format.</summary>
        public DateTimeOffset? EffectiveFrom { get; set; }
        /// <summary>The date and time when the recurring interval schedule ends, presented in ISO 8601 format.</summary>
        public DateTimeOffset? EffectiveTo { get; set; }
        /// <summary>The end date and time for the data extraction, in ISO 8601 format.This field applies only to schemas supporting date range extraction. The detailed schema documentation delivered with each data extract identifies the schemas and tables that support date range extraction.Additional notes on using ``startDate`` and ``endDate``:- If you provide only ``startDate`` or ``endDate`` (but not both), Data Connector uses that single date for both ``startDate`` and ``endDate``.- If you request more than the Maximum Date Range Allowed for an extraction, the default date range as documented in the schema documentation is returned.- For the ``activities`` service group, data replication can be delayed up to 20 minutes, so your requests should account for that delay.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public string? EndDate { get; set; }
#nullable restore
#else
        public string EndDate { get; set; }
#endif
        /// <summary>The ID of the data request.</summary>
        public Guid? Id { get; set; }
        /// <summary>The data request&apos;s active/inactive status. Possible values: ``true`` the request is active; ``false`` the request is inactive.</summary>
        public bool? IsActive { get; set; }
        /// <summary>The date and time the last job for this data request was scheduled to execute, presented in ISO 8601 format.</summary>
        public DateTimeOffset? LastQueuedAt { get; set; }
        /// <summary>(Legacy): A single project ID for the data request. Superseded by ``projectIdList``.</summary>
        public Guid? ProjectId { get; set; }
        /// <summary>A list of up to 50 project IDs included in the data request. This field contains the project IDs for which data is being extracted. If both ``projectId`` and ``projectIdList`` were included in the request, this field contains the values from ``projectIdList``.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public List<string>? ProjectIdList { get; set; }
#nullable restore
#else
        public List<string> ProjectIdList { get; set; }
#endif
        /// <summary>The types of projects to be included in a request. The possible values are:- ``all``: - all projects (default)- ``archived``: archived projects only- ``active``: active project only</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public string? ProjectStatus { get; set; }
#nullable restore
#else
        public string ProjectStatus { get; set; }
#endif
        /// <summary>The number of ``scheduleInterval`` units to wait between job execution for the request. For example, a ``scheduleInterval`` value of ``WEEK`` and a ``reoccuringInterval`` value of ``2`` means the job will run every two weeks.</summary>
        public int? ReoccuringInterval { get; set; }
        /// <summary>The scheduling interval unit for jobs spawned by this data request. This value is multiplied by the ``reoccurringInterval`` attribute to specify the length of the recurring interval at which jobs run. Possible values:- ``ONE_TIME``: Run the job only once- ``DAY``: Set the recurring job interval in days- ``WEEK``: Set the recurring job interval in weeks- ``MONTH``: Set the recurring job interval in months- ``YEAR``: Set the recurring job interval in years</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public string? ScheduleInterval { get; set; }
#nullable restore
#else
        public string ScheduleInterval { get; set; }
#endif
        /// <summary>Send a notification email to the user upon job completion. Values: true or false (default is true)</summary>
        public bool? SendEmail { get; set; }
        /// <summary>The service groups from which data has been extracted, separated by commas.Possible values: ``all``, ``activities``, ``admin``, ``assets``, ``checklists``, ``cost``, ``dailylogs``, ``forms``, ``iq``, ``issues``, ``locations``, ``markups``, ``meetingminutes``, ``photos``, ``relationships``, ``reviews``, ``rfis``, ``schedule``, ``sheets``, ``submittals``, ``submittalsacc``, ``transmittals``.Note that the ``admin`` service includes both project and account admin, and ``all`` indicates that the extract contains all currently available service groups.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public List<string>? ServiceGroups { get; set; }
#nullable restore
#else
        public List<string> ServiceGroups { get; set; }
#endif
        /// <summary>The start date and time for the data extraction, in ISO 8601 format.This field applies only to schemas supporting date range extraction. The detailed schema documentation delivered with each data extract identifies the schemas and tables that support date range extraction.Additional notes on using ``startDate`` and ``endDate``:- If you provide only ``startDate`` or ``endDate`` (but not both), Data Connector uses that single date for both ``startDate`` and ``endDate``.- If you request more than the Maximum Date Range Allowed for an extraction, the default date range as documented in the schema documentation is returned.- For the ``activities`` service group, data replication can be delayed up to 20 minutes, so your requests should account for that delay.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public string? StartDate { get; set; }
#nullable restore
#else
        public string StartDate { get; set; }
#endif
        /// <summary>The date and time the data request was last updated, presented in ISO 8601 format.</summary>
        public DateTimeOffset? UpdatedAt { get; set; }
        /// <summary>The BIM 360 / ACC user ID of the user who last updated the data request.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public string? UpdatedBy { get; set; }
#nullable restore
#else
        public string UpdatedBy { get; set; }
#endif
        /// <summary>
        /// Instantiates a new <see cref="global::Autodesk.ACC.DataConnector.DataConnector.V1.Accounts.Item.Requests.Item.WithRequestGetResponse"/> and sets the default values.
        /// </summary>
        public WithRequestGetResponse()
        {
            AdditionalData = new Dictionary<string, object>();
        }
        /// <summary>
        /// Creates a new instance of the appropriate class based on discriminator value
        /// </summary>
        /// <returns>A <see cref="global::Autodesk.ACC.DataConnector.DataConnector.V1.Accounts.Item.Requests.Item.WithRequestGetResponse"/></returns>
        /// <param name="parseNode">The parse node to use to read the discriminator value and create the object</param>
        public static global::Autodesk.ACC.DataConnector.DataConnector.V1.Accounts.Item.Requests.Item.WithRequestGetResponse CreateFromDiscriminatorValue(IParseNode parseNode)
        {
            if(ReferenceEquals(parseNode, null)) throw new ArgumentNullException(nameof(parseNode));
            return new global::Autodesk.ACC.DataConnector.DataConnector.V1.Accounts.Item.Requests.Item.WithRequestGetResponse();
        }
        /// <summary>
        /// The deserialization information for the current model
        /// </summary>
        /// <returns>A IDictionary&lt;string, Action&lt;IParseNode&gt;&gt;</returns>
        public virtual IDictionary<string, Action<IParseNode>> GetFieldDeserializers()
        {
            return new Dictionary<string, Action<IParseNode>>
            {
                { "accountId", n => { AccountId = n.GetGuidValue(); } },
                { "callbackUrl", n => { CallbackUrl = n.GetStringValue(); } },
                { "createdAt", n => { CreatedAt = n.GetDateTimeOffsetValue(); } },
                { "createdBy", n => { CreatedBy = n.GetStringValue(); } },
                { "createdByEmail", n => { CreatedByEmail = n.GetStringValue(); } },
                { "dateRange", n => { DateRange = n.GetStringValue(); } },
                { "description", n => { Description = n.GetStringValue(); } },
                { "effectiveFrom", n => { EffectiveFrom = n.GetDateTimeOffsetValue(); } },
                { "effectiveTo", n => { EffectiveTo = n.GetDateTimeOffsetValue(); } },
                { "endDate", n => { EndDate = n.GetStringValue(); } },
                { "id", n => { Id = n.GetGuidValue(); } },
                { "isActive", n => { IsActive = n.GetBoolValue(); } },
                { "lastQueuedAt", n => { LastQueuedAt = n.GetDateTimeOffsetValue(); } },
                { "projectId", n => { ProjectId = n.GetGuidValue(); } },
                { "projectIdList", n => { ProjectIdList = n.GetCollectionOfPrimitiveValues<string>()?.AsList(); } },
                { "projectStatus", n => { ProjectStatus = n.GetStringValue(); } },
                { "reoccuringInterval", n => { ReoccuringInterval = n.GetIntValue(); } },
                { "scheduleInterval", n => { ScheduleInterval = n.GetStringValue(); } },
                { "sendEmail", n => { SendEmail = n.GetBoolValue(); } },
                { "serviceGroups", n => { ServiceGroups = n.GetCollectionOfPrimitiveValues<string>()?.AsList(); } },
                { "startDate", n => { StartDate = n.GetStringValue(); } },
                { "updatedAt", n => { UpdatedAt = n.GetDateTimeOffsetValue(); } },
                { "updatedBy", n => { UpdatedBy = n.GetStringValue(); } },
            };
        }
        /// <summary>
        /// Serializes information the current object
        /// </summary>
        /// <param name="writer">Serialization writer to use to serialize this model</param>
        public virtual void Serialize(ISerializationWriter writer)
        {
            if(ReferenceEquals(writer, null)) throw new ArgumentNullException(nameof(writer));
            writer.WriteGuidValue("accountId", AccountId);
            writer.WriteStringValue("callbackUrl", CallbackUrl);
            writer.WriteDateTimeOffsetValue("createdAt", CreatedAt);
            writer.WriteStringValue("createdBy", CreatedBy);
            writer.WriteStringValue("createdByEmail", CreatedByEmail);
            writer.WriteStringValue("dateRange", DateRange);
            writer.WriteStringValue("description", Description);
            writer.WriteDateTimeOffsetValue("effectiveFrom", EffectiveFrom);
            writer.WriteDateTimeOffsetValue("effectiveTo", EffectiveTo);
            writer.WriteStringValue("endDate", EndDate);
            writer.WriteGuidValue("id", Id);
            writer.WriteBoolValue("isActive", IsActive);
            writer.WriteDateTimeOffsetValue("lastQueuedAt", LastQueuedAt);
            writer.WriteGuidValue("projectId", ProjectId);
            writer.WriteCollectionOfPrimitiveValues<string>("projectIdList", ProjectIdList);
            writer.WriteStringValue("projectStatus", ProjectStatus);
            writer.WriteIntValue("reoccuringInterval", ReoccuringInterval);
            writer.WriteStringValue("scheduleInterval", ScheduleInterval);
            writer.WriteBoolValue("sendEmail", SendEmail);
            writer.WriteCollectionOfPrimitiveValues<string>("serviceGroups", ServiceGroups);
            writer.WriteStringValue("startDate", StartDate);
            writer.WriteDateTimeOffsetValue("updatedAt", UpdatedAt);
            writer.WriteStringValue("updatedBy", UpdatedBy);
            writer.WriteAdditionalData(AdditionalData);
        }
    }
}
#pragma warning restore CS0618
