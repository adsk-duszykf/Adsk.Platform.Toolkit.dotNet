// <auto-generated/>
#pragma warning disable CS0618
using Microsoft.Kiota.Abstractions.Extensions;
using Microsoft.Kiota.Abstractions.Serialization;
using System.Collections.Generic;
using System.IO;
using System;
namespace Autodesk.ACC.DataConnector.DataConnector.V1.Accounts.Item.Requests
{
    [global::System.CodeDom.Compiler.GeneratedCode("Kiota", "1.0.0")]
    #pragma warning disable CS1591
    public partial class RequestsPostRequestBody : IAdditionalDataHolder, IParsable
    #pragma warning restore CS1591
    {
        /// <summary>Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.</summary>
        public IDictionary<string, object> AdditionalData { get; set; }
        /// <summary>The callback URL specified for the data request. If specified, the Data Connection service calls the URL each time a job executes for the request. The service sends a POST request that provides job execution information. The JSON payload in the POST request contains the following: ``{ ``accountId``: ``account_id``, ``requestId``: ``request_id``, ``jobId``: ``data_connector_job_id``, ``state``: ``complete``, ``success``: true or false }``.If not specified, the Data Connection service does not provide a callback.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public string? CallbackUrl { get; set; }
#nullable restore
#else
        public string CallbackUrl { get; set; }
#endif
        /// <summary>Specifies the timeframe for extracting data in a scheduled request (DAY, WEEK, MONTH, YEAR). Currently, it is applicable only to the Activities service. Possible values:- ``TODAY``: The current calendar day, from 00:00 UTC to the time the request is made.- ``YESTERDAY``: The entire previous calendar day (00:00 UTC to 23:59 UTC).- ``PAST_7_DAYS``: The last 7 days, including the current day.- ``MONTH_TO_DATE``: From the start of the current calendar month (00:00 UTC on the 1st) to the time the request is made.- ``LAST_MONTH``: The entire previous calendar month (00:00 UTC on the 1st to 23:59 UTC on the last day).</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public string? DateRange { get; set; }
#nullable restore
#else
        public string DateRange { get; set; }
#endif
        /// <summary>The user-entered description of this data request.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public string? Description { get; set; }
#nullable restore
#else
        public string Description { get; set; }
#endif
        /// <summary>The date and time when a one-time job execution or a recurring interval schedule begins, presented in ISO 8601 format. If the date and time is before the current time, execution of scheduling begins immediately. This value is required.</summary>
        public DateTimeOffset? EffectiveFrom { get; set; }
        /// <summary>The date and time when the recurring interval schedule ends, presented in ISO 8601 format. This value must not be supplied for ``scheduleInterval`` values of ``ONE_TIME``, but is required for all other ``scheduleInterval`` values.</summary>
        public DateTimeOffset? EffectiveTo { get; set; }
        /// <summary>The end date and time for the data extraction, in ISO 8601 format.This field applies only to schemas supporting date range extraction. The detailed schema documentation delivered with each data extract identifies the schemas and tables that support date range extraction.Additional notes on using ``startDate`` and ``endDate``:- If you provide only ``startDate`` or ``endDate`` (but not both), Data Connector uses that single date for both ``startDate`` and ``endDate``.- If you request more than the Maximum Date Range Allowed for an extraction, the default date range as documented in the schema documentation is returned.- For the ``activities`` service group, data replication can be delayed up to 20 minutes, so your requests should account for that delay.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public string? EndDate { get; set; }
#nullable restore
#else
        public string EndDate { get; set; }
#endif
        /// <summary>The data request&apos;s active/inactive status. Possible values: ``true`` the request is active; ``false`` the request is inactive. If not supplied, the default value is ``true``.</summary>
        public bool? IsActive { get; set; }
        /// <summary>(Legacy): A single project ID for the data request. Superseded by ``projectIdList``.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public string? ProjectId { get; set; }
#nullable restore
#else
        public string ProjectId { get; set; }
#endif
        /// <summary>A list of up to 50 project IDs for the data request, which can include a single project or multiple projects. If ``projectId`` is also included, ``projectIdList`` takes precedence. Required for users with project admin permissions. Optional for users with executive overview permissions, who by default receive data for all projects unless ``projectIdList`` is provided.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public List<string>? ProjectIdList { get; set; }
#nullable restore
#else
        public List<string> ProjectIdList { get; set; }
#endif
        /// <summary>The types of projects to be included in a request. The possible values are:- ``all``: - all projects (default)- ``archived``: archived projects only- ``active``: active project only</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public string? ProjectStatus { get; set; }
#nullable restore
#else
        public string ProjectStatus { get; set; }
#endif
        /// <summary>The number of ``scheduleInterval`` units to wait between job execution for the request. For example, a ``scheduleInterval`` value of ``WEEK`` and a ``reoccuringInterval`` value of ``2`` means the job will run every two weeks.This value is required and must be a non-zero integer for all values of ``scheduleInterval`` except for a ``scheduleInterval`` value of ``ONE_TIME``, in which case this value is ignored.</summary>
        public int? ReoccuringInterval { get; set; }
        /// <summary>The scheduling interval unit for jobs spawned by this data request. This value is multiplied by the ``reoccurringInterval`` attribute to specify the length of the recurring interval at which jobs run. Possible values:- ``ONE_TIME``: Run the job only once- ``DAY``: Set the recurring job interval in days- ``WEEK``: Set the recurring job interval in weeks- ``MONTH``: Set the recurring job interval in months- ``YEAR``: Set the recurring job interval in yearsNote that recurring jobs start at the day and time when the request first spawns a job. This may be at the date and time specified in the attribute ``effectiveFrom``.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public string? ScheduleInterval { get; set; }
#nullable restore
#else
        public string ScheduleInterval { get; set; }
#endif
        /// <summary>Send a notification email to the user upon job completion. Values: true or false (default is true)</summary>
        public bool? SendEmail { get; set; }
        /// <summary>The service groups from which to extract data, separated by commas. This required value must identify at least one service group.Possible values: ``all``, ``activities``, ``admin``, ``assets``, ``checklists``, ``cost``, ``dailylogs``, ``forms``, ``iq``, ``issues``, ``locations``, ``markups``, ``meetingminutes``, ``photos``, ``relationships``, ``reviews``, ``rfis``, ``schedule``, ``sheets``, ``submittals``, ``submittalsacc``, ``transmittals``.Note that the ``admin`` service includes both project and account admin, and ``all`` produces an extract containing all currently available service groups.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public List<string>? ServiceGroups { get; set; }
#nullable restore
#else
        public List<string> ServiceGroups { get; set; }
#endif
        /// <summary>The start date and time for the data extraction, in ISO 8601 format.This field applies only to schemas supporting date range extraction. The detailed schema documentation delivered with each data extract identifies the schemas and tables that support date range extraction.Additional notes on using ``startDate`` and ``endDate``:- If you provide only ``startDate`` or ``endDate`` (but not both), Data Connector uses that single date for both ``startDate`` and ``endDate``.- If you request more than the Maximum Date Range Allowed for an extraction, the default date range as documented in the schema documentation is returned.- For the ``activities`` service group, data replication can be delayed up to 20 minutes, so your requests should account for that delay.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public string? StartDate { get; set; }
#nullable restore
#else
        public string StartDate { get; set; }
#endif
        /// <summary>
        /// Instantiates a new <see cref="global::Autodesk.ACC.DataConnector.DataConnector.V1.Accounts.Item.Requests.RequestsPostRequestBody"/> and sets the default values.
        /// </summary>
        public RequestsPostRequestBody()
        {
            AdditionalData = new Dictionary<string, object>();
        }
        /// <summary>
        /// Creates a new instance of the appropriate class based on discriminator value
        /// </summary>
        /// <returns>A <see cref="global::Autodesk.ACC.DataConnector.DataConnector.V1.Accounts.Item.Requests.RequestsPostRequestBody"/></returns>
        /// <param name="parseNode">The parse node to use to read the discriminator value and create the object</param>
        public static global::Autodesk.ACC.DataConnector.DataConnector.V1.Accounts.Item.Requests.RequestsPostRequestBody CreateFromDiscriminatorValue(IParseNode parseNode)
        {
            if(ReferenceEquals(parseNode, null)) throw new ArgumentNullException(nameof(parseNode));
            return new global::Autodesk.ACC.DataConnector.DataConnector.V1.Accounts.Item.Requests.RequestsPostRequestBody();
        }
        /// <summary>
        /// The deserialization information for the current model
        /// </summary>
        /// <returns>A IDictionary&lt;string, Action&lt;IParseNode&gt;&gt;</returns>
        public virtual IDictionary<string, Action<IParseNode>> GetFieldDeserializers()
        {
            return new Dictionary<string, Action<IParseNode>>
            {
                { "callbackUrl", n => { CallbackUrl = n.GetStringValue(); } },
                { "dateRange", n => { DateRange = n.GetStringValue(); } },
                { "description", n => { Description = n.GetStringValue(); } },
                { "effectiveFrom", n => { EffectiveFrom = n.GetDateTimeOffsetValue(); } },
                { "effectiveTo", n => { EffectiveTo = n.GetDateTimeOffsetValue(); } },
                { "endDate", n => { EndDate = n.GetStringValue(); } },
                { "isActive", n => { IsActive = n.GetBoolValue(); } },
                { "projectId", n => { ProjectId = n.GetStringValue(); } },
                { "projectIdList", n => { ProjectIdList = n.GetCollectionOfPrimitiveValues<string>()?.AsList(); } },
                { "projectStatus", n => { ProjectStatus = n.GetStringValue(); } },
                { "reoccuringInterval", n => { ReoccuringInterval = n.GetIntValue(); } },
                { "scheduleInterval", n => { ScheduleInterval = n.GetStringValue(); } },
                { "sendEmail", n => { SendEmail = n.GetBoolValue(); } },
                { "serviceGroups", n => { ServiceGroups = n.GetCollectionOfPrimitiveValues<string>()?.AsList(); } },
                { "startDate", n => { StartDate = n.GetStringValue(); } },
            };
        }
        /// <summary>
        /// Serializes information the current object
        /// </summary>
        /// <param name="writer">Serialization writer to use to serialize this model</param>
        public virtual void Serialize(ISerializationWriter writer)
        {
            if(ReferenceEquals(writer, null)) throw new ArgumentNullException(nameof(writer));
            writer.WriteStringValue("callbackUrl", CallbackUrl);
            writer.WriteStringValue("dateRange", DateRange);
            writer.WriteStringValue("description", Description);
            writer.WriteDateTimeOffsetValue("effectiveFrom", EffectiveFrom);
            writer.WriteDateTimeOffsetValue("effectiveTo", EffectiveTo);
            writer.WriteStringValue("endDate", EndDate);
            writer.WriteBoolValue("isActive", IsActive);
            writer.WriteStringValue("projectId", ProjectId);
            writer.WriteCollectionOfPrimitiveValues<string>("projectIdList", ProjectIdList);
            writer.WriteStringValue("projectStatus", ProjectStatus);
            writer.WriteIntValue("reoccuringInterval", ReoccuringInterval);
            writer.WriteStringValue("scheduleInterval", ScheduleInterval);
            writer.WriteBoolValue("sendEmail", SendEmail);
            writer.WriteCollectionOfPrimitiveValues<string>("serviceGroups", ServiceGroups);
            writer.WriteStringValue("startDate", StartDate);
            writer.WriteAdditionalData(AdditionalData);
        }
    }
}
#pragma warning restore CS0618
